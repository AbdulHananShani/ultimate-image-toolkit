# --- SERVER BLOCK 1: Handles all insecure HTTP traffic ---
server {
    # Tells Nginx to listen for any traffic coming to port 80 (the standard HTTP port).
    listen 80;

    # Tells Nginx which domain names this block should respond to.
    server_name pixlyze.com www.pixlyze.com;

    # This is a special rule for the Let's Encrypt renewal process.
    # When Certbot tries to renew, it places a file here for the server to find.
    location /.well-known/acme-challenge/ {
        # Tells Nginx to look for the verification file in this specific directory.
        root /var/www/certbot;
    }

    # This is a "catch-all" for any other request to port 80.
    location / {
        # This is a permanent redirect command. It tells the user's browser:
        # "This page has moved. Please go to the secure HTTPS version instead."
        return 301 https://$host$request_uri;
    }
}


# --- SERVER BLOCK 2: Handles all secure HTTPS traffic ---
server {
    # Tells Nginx to listen for traffic on port 443 (the standard HTTPS port) and to enable SSL.
    listen 443 ssl;

    # Tells Nginx this block is also for your domain names.
    server_name pixlyze.com www.pixlyze.com;

    # --- SSL Certificate Configuration ---
    # Points to the main certificate file that Certbot created for you.
    ssl_certificate /etc/letsencrypt/live/pixlyze.com/fullchain.pem;
    # Points to the private key file that corresponds to your certificate.
    ssl_certificate_key /etc/letsencrypt/live/pixlyze.com/privkey.pem;

    # Includes a file of recommended security settings provided by Certbot.
    include /etc/letsencrypt/options-ssl-nginx.conf; 
    # Points to a file that improves the security of the SSL connection.
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    # --- End SSL Configuration ---


    # --- Application Routing ---
    # This block handles all other requests (like to the homepage, compressor, etc.).
    location / {
        # This is the most important line: it forwards the request to our Python app,
        # which Docker knows by the service name 'web', running on its internal port 8000.
        proxy_pass http://web:8000;
        
        # These lines pass along important information about the original request
        # so Flask knows the real domain name and user IP address.
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # This tells Nginx to serve your CSS and JS files directly, which is very fast.
    location /static/ { 
        alias /var/www/static/; 
    }
    
    # This tells Nginx to serve the user-uploaded images directly.
    location /uploads/ { 
        alias /var/www/uploads/; 
    }
}