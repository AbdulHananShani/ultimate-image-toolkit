# ----------------------------
# SSL / Reverse-proxy Nginx
# ----------------------------
# Purpose:
#  - Terminate TLS (Cloudflare Origin cert) on the container
#  - Proxy requests to the backend "web" container (Flask / Gunicorn)
#  - Redirect HTTP -> HTTPS
#  - Redirect requests to the server IP to the canonical domain
#  - Provide caching and gzip for static assets (SEO / perf)
# ----------------------------

# --------------- IP redirect (HTTP) ---------------
# If someone hits the server IP over HTTP, redirect them to the canonical HTTPS domain.
server {
    listen 80;                 # listen on IPv4 port 80
    listen [::]:80;            # listen on IPv6 port 80 (if host/network has IPv6)
    server_name 172.236.0.96;  # <-- REPLACE with your actual server IP if different

    # Permanently redirect to the canonical HTTPS domain.
    return 301 https://pixlyze.com$request_uri;
}

# --------------- IP redirect (HTTPS) ---------------
# If someone tries to access the bare IP via HTTPS, redirect to canonical domain.
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name 172.236.0.96;  # <-- server IP

    # Path to the origin cert mounted into the container (change paths if you mount differently)
    ssl_certificate /etc/ssl/certs/cloudflare.cert;
    ssl_certificate_key /etc/ssl/private/cloudflare.key;

    # Minimal TLS settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    return 301 https://pixlyze.com$request_uri;
}

# --------------- HTTP -> HTTPS redirect for your domain ---------------
server {
    listen 80;
    listen [::]:80;
    server_name pixlyze.com www.pixlyze.com;

    # Redirect any HTTP request to HTTPS (preserve path & query)
    return 301 https://$host$request_uri;
}

# --------------- Main HTTPS server for pixlyze.com ---------------
server {
    listen 443 ssl http2;                 # HTTP/2 is good for performance
    listen [::]:443 ssl http2;
    server_name pixlyze.com www.pixlyze.com;

    # Certificate and key (these paths must be mounted into the container).
    ssl_certificate /etc/ssl/certs/cloudflare.cert;
    ssl_certificate_key /etc/ssl/private/cloudflare.key;

    # Security: modern TLS settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Recommended headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # ------------------ Performance: gzip ------------------
    gzip on;
    gzip_min_length 1000;
    gzip_types text/plain text/css application/json application/javascript application/xml application/rss+xml image/svg+xml;
    gzip_proxied any;

    # ------------------ Static files cache ------------------
    # Cache images, css, js on the client for a long time
    location ~* \.(?:ico|css|js|gif|jpe?g|png|woff2?|eot|ttf|svg|pdf)$ {
        expires 30d;
        access_log off;
        add_header Cache-Control "public";
    }

    
    # ------------------ Reverse proxy to backend ------------------
    location / {
        # Proxy requests to the Docker service named "web" on the port your app listens to.
        # Make sure docker-compose has "expose: - '8000'" or similar for this service.
        proxy_pass http://web:8000;

        # Common headers to forward client info (important for Flask apps)
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Websocket support (if needed)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeout adjustments (increase if upstream is slow)
        proxy_read_timeout 90;
        proxy_connect_timeout 5s;
    }

    # Optional: custom error pages (useful for SEO UX)
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}
